//==============================================================================
//      File:           $URL$
//      Version:        Automatically generated by 'System Verilog to VPI' script
//      Author:         Script By Tom Golubev
//      Copyright:      Copyright 2005-2009 UC Santa Cruz
//==============================================================================

//==============================================================================
//     Section:        License
//==============================================================================
//      Copyright (c) 2005-2009, Regents of the University ofCalifornia
//      All rights reserved.
//
//      Redistribution and use in source and binary forms, with or without modification,
//      are permitted provided thatthefollowing conditions are met:
//
//              - Redistributions of source code must retain the above copyright notice,
//                      this list ofconditions and the following disclaimer.
//              - Redistributions in binary form must reproduce the above copyright
//                      notice, this list ofconditions and the following disclaimer
//                      in the documentation and/or other materials provided with the
//                      distribution.
//             - Neither the name of the University of California, Santa Cruz nor the
//                      names of its contributors may be used to endorse or promote
//                     products derived from this software without specific prior
//                      written permission.
//
//      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHTHOLDERSAND CONTRIBUTORS "AS IS" AND
//      ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//      WARRANTIES OF MERCHANTABILITY ANDFITNESS FOR A PARTICULAR PURPOSE ARE
//      DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
//      ANY DIRECT, INDIRECT, INCIDENTAL,SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//      LOSS OF USE, DATA, ORPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
//      ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//      (INCLUDING NEGLIGENCE OROTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//      SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//==============================================================================



#ifndef H264_TYPES_tb
#define H264_TYPES_tb


class InputPacketType : public SharedAllClass{

  public: 
	InputPacketType(vpiHandle *h=0, SharedAllClass *obj = 0, char *name="default", uint32_t bits=80)
		:BitStream_buffer_input(0, obj?obj:this, "BitStream_buffer_input", 16)
		,ext_frame_RAM0_data(0, obj?obj:this, "ext_frame_RAM0_data", 32)
		,ext_frame_RAM1_data(0, obj?obj:this, "ext_frame_RAM1_data", 32)
	{
	 ttb_name =name;            
	 handle = h;
	 num_bits = bits;
	 if (bits > 64){ 
	   bit_array = new char[bits];
	   for (uint32_t i = 0; i < num_bits; i++) 
	      bit_array[i] = '0';
	   }else{
	      bit_array = 0;
	 }
	
	 if(obj)
	   top_obj = obj;
	 else  
	   top_obj = this; 
	}// /Constructor

	 GenType                   BitStream_buffer_input; 	
	 GenType                   ext_frame_RAM0_data; 	
	 GenType                   ext_frame_RAM1_data; 	

  public:

	const char *ttb_read(const char *str) {

		str = BitStream_buffer_input.ttb_read(str);

		str = ext_frame_RAM0_data.ttb_read(str);

		str = ext_frame_RAM1_data.ttb_read(str);
		return str;
	}// /read fn


	char *ttb_write(char *str) {

		str = BitStream_buffer_input.ttb_write(str);

		str = ext_frame_RAM0_data.ttb_write(str);

		str = ext_frame_RAM1_data.ttb_write(str);
		return str;
	}// /write fn

 }; //


class OutputPacketType : public SharedAllClass{

  public: 
	OutputPacketType(vpiHandle *h=0, SharedAllClass *obj = 0, char *name="default", uint32_t bits=89)
		:BitStream_ram_ren(0, obj?obj:this, "BitStream_ram_ren", 1)
		,BitStream_ram_addr(0, obj?obj:this, "BitStream_ram_addr", 17)
		,pic_num(0, obj?obj:this, "pic_num", 6)
		,ext_frame_RAM0_cs_n(0, obj?obj:this, "ext_frame_RAM0_cs_n", 1)
		,ext_frame_RAM0_wr(0, obj?obj:this, "ext_frame_RAM0_wr", 1)
		,ext_frame_RAM0_addr(0, obj?obj:this, "ext_frame_RAM0_addr", 14)
		,ext_frame_RAM1_cs_n(0, obj?obj:this, "ext_frame_RAM1_cs_n", 1)
		,ext_frame_RAM1_wr(0, obj?obj:this, "ext_frame_RAM1_wr", 1)
		,ext_frame_RAM1_addr(0, obj?obj:this, "ext_frame_RAM1_addr", 14)
		,dis_frame_RAM_din(0, obj?obj:this, "dis_frame_RAM_din", 32)
		,slice_header_s6(0, obj?obj:this, "slice_header_s6", 1)
	{
	 ttb_name =name;            
	 handle = h;
	 num_bits = bits;
	 if (bits > 64){ 
	   bit_array = new char[bits];
	   for (uint32_t i = 0; i < num_bits; i++) 
	      bit_array[i] = '0';
	   }else{
	      bit_array = 0;
	 }
	
	 if(obj)
	   top_obj = obj;
	 else  
	   top_obj = this; 
	}// /Constructor

	 GenType                   BitStream_ram_ren; 	
	 GenType                   BitStream_ram_addr; 	
	 GenType                   pic_num; 	
	 GenType                   ext_frame_RAM0_cs_n;
	 GenType                   ext_frame_RAM0_wr;
	 GenType                   ext_frame_RAM0_addr;
	 GenType                   ext_frame_RAM1_cs_n;
	 GenType                   ext_frame_RAM1_wr;
	 GenType                   ext_frame_RAM1_addr;
	 GenType                   dis_frame_RAM_din;
	 GenType                   slice_header_s6;

  public:

	const char *ttb_read(const char *str) {

		str = BitStream_ram_ren.ttb_read(str);
		str = BitStream_ram_addr.ttb_read(str);
		str = pic_num.ttb_read(str);
		str = ext_frame_RAM0_cs_n.ttb_read(str);
		str = ext_frame_RAM0_wr.ttb_read(str);
		str = ext_frame_RAM0_addr.ttb_read(str);
		str = ext_frame_RAM1_cs_n.ttb_read(str);
		str = ext_frame_RAM1_wr.ttb_read(str);
		str = ext_frame_RAM1_addr.ttb_read(str);
		str = dis_frame_RAM_din.ttb_read(str);
		str = slice_header_s6.ttb_read(str);
		return str;
	}// /read fn


	char *ttb_write(char *str) {

		str = BitStream_ram_ren.ttb_write(str);
		str = BitStream_ram_addr.ttb_write(str);
		str = pic_num.ttb_write(str);
		str = ext_frame_RAM0_cs_n.ttb_write(str);
		str = ext_frame_RAM0_wr.ttb_write(str);
		str = ext_frame_RAM0_addr.ttb_write(str);
		str = ext_frame_RAM1_cs_n.ttb_write(str);
		str = ext_frame_RAM1_wr.ttb_write(str);
		str = ext_frame_RAM1_addr.ttb_write(str);
		str = dis_frame_RAM_din.ttb_write(str);
		str = slice_header_s6.ttb_write(str);
		return str;
	}// /write fn

 }; //

#endif
